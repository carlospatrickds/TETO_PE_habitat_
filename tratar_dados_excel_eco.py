import streamlit as st
import pandas as pd
import numpy as np
from datetime import datetime
import io
import unicodedata

# Configura√ß√£o da p√°gina
st.set_page_config(
    page_title="Consulta de Comunidades", 
    page_icon="üèòÔ∏è", 
    layout="wide",
    initial_sidebar_state="expanded"
)

st.title("üèòÔ∏è Sistema de Consulta - Escuta de Comunidades")
st.markdown("---")

# Fun√ß√£o para normalizar texto (remover acentos e converter para min√∫sculas)
def normalizar_texto(texto):
    """Remove acentos e converte para min√∫sculas para busca insensitive"""
    if pd.isna(texto):
        return ""
    texto = str(texto)
    # Remove acentos
    texto = unicodedata.normalize('NFKD', texto).encode('ASCII', 'ignore').decode('ASCII')
    return texto.lower().strip()

# Fun√ß√£o para criar label descritivo das colunas
def criar_label_coluna(nome_coluna, dados_coluna, max_chars=30):
    """Cria um label descritivo com nome da coluna e amostra de valores"""
    nome_display = nome_coluna if len(nome_coluna) <= max_chars else nome_coluna[:max_chars-3] + "..."
    
    valores_nao_vazios = dados_coluna.dropna().unique()
    if len(valores_nao_vazios) > 0:
        amostra_valores = [str(x) for x in valores_nao_vazios[:3] if str(x) not in ['', 'nan', 'NaN']]
        if amostra_valores:
            amostra_text = ", ".join(amostra_valores)
            if len(amostra_text) > 25:
                amostra_text = amostra_text[:22] + "..."
            return f"{nome_display} ‚îÇ üìä {amostra_text}"
    
    return f"{nome_display} ‚îÇ üìù {len(dados_coluna.dropna())} valores"

# Fun√ß√£o para buscar valores similares
def encontrar_valores_similares(valor_busca, lista_valores, limite=5):
    """Encontra valores similares na lista (busca case insensitive e sem acentos)"""
    if not valor_busca:
        return []
    
    valor_busca_normalizado = normalizar_texto(valor_busca)
    similares = []
    
    for valor in lista_valores:
        if valor_busca_normalizado in normalizar_texto(valor):
            similares.append(valor)
            if len(similares) >= limite:
                break
    
    return similares

# Upload do arquivo
uploaded_file = st.file_uploader("üì§ Envie sua planilha Excel", type=["xlsx"])

if uploaded_file:
    try:
        # Ler o arquivo Excel
        df = pd.read_excel(uploaded_file)
        
        # Remover colunas completamente vazias
        df = df.dropna(axis=1, how='all')
        
        # Preencher NaN com string vazia para colunas de texto
        for col in df.columns:
            if df[col].dtype == 'object':
                df[col] = df[col].fillna('')
        
        st.success(f"‚úÖ Planilha carregada com sucesso! {len(df)} registros e {len(df.columns)} colunas encontradas.")
        
        # Sidebar para filtros
        st.sidebar.header("üîç Filtros de Consulta")
        
        # Criar labels descritivos para todas as colunas
        colunas_com_labels = []
        for coluna in df.columns:
            label = criar_label_coluna(coluna, df[coluna])
            colunas_com_labels.append((coluna, label))
        
        # Selecionar colunas para filtro
        colunas_filtro_selecionadas = st.sidebar.multiselect(
            "Selecione as colunas para filtrar:",
            options=[label for _, label in colunas_com_labels],
            default=[label for _, label in colunas_com_labels[:3]] if len(colunas_com_labels) >= 3 else [label for _, label in colunas_com_labels],
            help="Cada coluna selecionada mostrar√° um filtro espec√≠fico abaixo",
            max_selections=6
        )
        
        # Mapear labels de volta para nomes das colunas
        label_para_coluna = {label: coluna for coluna, label in colunas_com_labels}
        colunas_filtro = [label_para_coluna[label] for label in colunas_filtro_selecionadas]
        
        filtros_aplicados = {}
        
        # Criar filtros din√¢micos para cada coluna selecionada
        for coluna in colunas_filtro:
            if coluna in df.columns:
                st.sidebar.markdown(f"**üéØ Filtro: {coluna}**")
                
                # Verificar se a coluna tem dados
                if len(df[coluna].dropna()) > 0:
                    # Para colunas textuais - SEMPRE permitir sele√ß√£o m√∫ltipla
                    if df[coluna].dtype in ['object', 'string']:
                        valores_unicos = df[coluna].dropna().unique()
                        valores_unicos = [str(x) for x in valores_unicos if str(x) not in ['', 'nan', 'NaN']]
                        
                        if len(valores_unicos) > 0:
                            # Sistema de busca + sele√ß√£o m√∫ltipla para TODAS as colunas textuais
                            st.sidebar.write("**üîç Buscar valores:**")
                            
                            # Campo de busca
                            busca_texto = st.sidebar.text_input(
                                f"Digite para buscar em {coluna}:",
                                placeholder="Ex: vila, centro, norte...",
                                key=f"busca_{coluna}",
                                help="Busque valores por partes do texto (ignora acentos e mai√∫sculas)"
                            )
                            
                            # Encontrar valores similares baseado na busca
                            valores_disponiveis = sorted(valores_unicos)
                            
                            if busca_texto:
                                valores_similares = encontrar_valores_similares(busca_texto, valores_unicos)
                                if valores_similares:
                                    st.sidebar.success(f"üéØ {len(valores_similares)} valor(es) encontrado(s)")
                                    valores_disponiveis = valores_similares
                                else:
                                    st.sidebar.warning("‚ùå Nenhum valor encontrado")
                                    valores_disponiveis = []
                            
                            # Sele√ß√£o m√∫ltipla sempre dispon√≠vel
                            selecao = st.sidebar.multiselect(
                                f"**Selecione os valores para {coluna}:**",
                                options=valores_disponiveis,
                                default=[],
                                help="üí° **DICA:** Selecione m√∫ltiplas varia√ß√µes (com/sem acento, mai√∫sculas/min√∫sculas)",
                                key=f"multiselect_{coluna}"
                            )
                            
                            # Sugest√µes autom√°ticas para valores comuns
                            if not busca_texto and not selecao:
                                # Mostrar valores mais frequentes como sugest√£o
                                valores_frequentes = df[coluna].value_counts().head(3).index.tolist()
                                if valores_frequentes:
                                    st.sidebar.caption(f"üí° Sugest√µes: {', '.join(map(str, valores_frequentes))}")
                            
                            if selecao:
                                filtros_aplicados[coluna] = selecao
                                st.sidebar.success(f"‚úÖ {len(selecao)} valor(es) selecionado(s)")
                            
                            # Estat√≠sticas
                            st.sidebar.caption(f"üìä {len(valores_unicos)} valores √∫nicos encontrados")
                    
                    # Para colunas num√©ricas
                    elif np.issubdtype(df[coluna].dtype, np.number):
                        min_val = float(df[coluna].min())
                        max_val = float(df[coluna].max())
                        
                        if min_val != max_val:
                            faixa = st.sidebar.slider(
                                f"Faixa de valores em **{coluna}**:",
                                min_value=min_val,
                                max_value=max_val,
                                value=(min_val, max_val),
                                help=f"Selecione a faixa de valores para {coluna}",
                                key=f"faixa_{coluna}"
                            )
                            filtros_aplicados[coluna] = faixa
                            st.sidebar.caption(f"üìà Valores de {min_val:.2f} a {max_val:.2f}")
                    
                    # Para colunas booleanas ou com poucos valores √∫nicos
                    elif df[coluna].nunique() <= 10:
                        valores_unicos = df[coluna].dropna().unique()
                        selecao = st.sidebar.multiselect(
                            f"Valores em **{coluna}**:",
                            options=valores_unicos,
                            default=[],
                            help=f"Selecione m√∫ltiplos valores para {coluna}",
                            key=f"multiselect_small_{coluna}"
                        )
                        if selecao:
                            filtros_aplicados[coluna] = selecao
                
                else:
                    st.sidebar.warning(f"‚ö†Ô∏è Coluna '{coluna}' est√° vazia")
                
                st.sidebar.markdown("---")
        
        # Bot√£o para limpar filtros
        col_btn1, col_btn2 = st.sidebar.columns(2)
        with col_btn1:
            if st.button("üßπ Limpar Filtros", use_container_width=True):
                filtros_aplicados = {}
                st.rerun()
        with col_btn2:
            if st.button("üîÑ Recarregar", use_container_width=True):
                st.rerun()
        
        # Aplicar filtros
        df_filtrado = df.copy()
        
        for coluna, filtro in filtros_aplicados.items():
            if isinstance(filtro, list):  # Filtro de m√∫ltiplos valores
                # Converter tudo para string para compara√ß√£o insensitive
                mask = df_filtrado[coluna].astype(str).apply(lambda x: normalizar_texto(x)).isin(
                    [normalizar_texto(str(x)) for x in filtro]
                )
                df_filtrado = df_filtrado[mask]
            elif isinstance(filtro, tuple):  # Filtro de faixa num√©rica
                mask = (df_filtrado[coluna] >= filtro[0]) & (df_filtrado[coluna] <= filtro[1])
                df_filtrado = df_filtrado[mask]
        
        # Mostrar estat√≠sticas dos filtros
        st.sidebar.markdown("### üìä Estat√≠sticas")
        col_stat1, col_stat2 = st.sidebar.columns(2)
        with col_stat1:
            st.metric("Registros", len(df_filtrado))
        with col_btn2:
            st.metric("Total", len(df))
        
        taxa_filtro = (len(df_filtrado)/len(df)*100) if len(df) > 0 else 0
        st.sidebar.metric("Taxa", f"{taxa_filtro:.1f}%")
        
        # √Årea principal de resultados
        col1, col2 = st.columns([3, 1])
        
        with col1:
            st.subheader(f"üìä Resultados da Consulta ({len(df_filtrado)} registros)")
            
            if len(df_filtrado) > 0:
                # Selecionar colunas para exibi√ß√£o com labels
                colunas_exibicao_labels = st.multiselect(
                    "Selecione as colunas para exibir:",
                    options=[label for _, label in colunas_com_labels],
                    default=[label for _, label in colunas_com_labels[:8]] if len(colunas_com_labels) >= 8 else [label for _, label in colunas_com_labels],
                    help="Escolha quais colunas mostrar na tabela"
                )
                
                # Converter labels de volta para nomes das colunas
                colunas_exibicao = [label_para_coluna[label] for label in colunas_exibicao_labels]
                
                if colunas_exibicao:
                    df_exibicao = df_filtrado[colunas_exibicao]
                    
                    # Pagina√ß√£o
                    items_per_page = 20
                    total_pages = max(1, (len(df_exibicao) - 1) // items_per_page + 1)
                    
                    col_page1, col_page2, col_page3 = st.columns([1, 2, 1])
                    with col_page2:
                        page_number = st.number_input(
                            "P√°gina:", 
                            min_value=1, 
                            max_value=total_pages, 
                            value=1,
                            help=f"Total de {total_pages} p√°ginas"
                        )
                    
                    start_idx = (page_number - 1) * items_per_page
                    end_idx = start_idx + items_per_page
                    
                    # Mostrar dataframe com os nomes originais das colunas
                    st.dataframe(
                        df_exibicao.iloc[start_idx:end_idx],
                        use_container_width=True,
                        height=500
                    )
                    
                    st.caption(f"Mostrando registros {start_idx + 1} a {min(end_idx, len(df_exibicao))} de {len(df_exibicao)}")
                else:
                    st.info("üìù Selecione pelo menos uma coluna para exibir.")
            else:
                st.warning("üîç Nenhum registro encontrado com os filtros aplicados. Tente ajustar os crit√©rios de busca.")
        
        with col2:
            st.subheader("üìã Resumo da Consulta")
            
            # Informa√ß√µes gerais
            st.metric("Colunas", len(df.columns))
            st.metric("Filtros", len(filtros_aplicados))
            
            # Mostrar filtros ativos
            if filtros_aplicados:
                st.write("**üéØ Filtros ativos:**")
                for coluna, filtro in filtros_aplicados.items():
                    if isinstance(filtro, list):
                        valores = ", ".join(map(str, filtro[:3]))  # Mostra apenas os 3 primeiros
                        if len(filtro) > 3:
                            valores += f"... (+{len(filtro)-3})"
                        st.write(f"‚Ä¢ **{coluna}:** {valores}")
                    else:
                        st.write(f"‚Ä¢ **{coluna}:** {filtro[0]:.2f} a {filtro[1]:.2f}")
            else:
                st.info("‚ÑπÔ∏è Nenhum filtro aplicado")
            
            # Bot√£o r√°pido para exportar
            if len(df_filtrado) > 0:
                st.markdown("---")
                st.write("**üì§ Exporta√ß√£o R√°pida**")
                
                # Exporta√ß√£o r√°pida em CSV
                csv_rapido = df_filtrado.to_csv(index=False, encoding='utf-8-sig').encode('utf-8-sig')
                st.download_button(
                    label="üíæ Baixar CSV",
                    data=csv_rapido,
                    file_name=f"consulta_rapida_{datetime.now().strftime('%H%M')}.csv",
                    mime="text/csv",
                    use_container_width=True
                )
        
        # Se√ß√£o de exporta√ß√£o completa
        if len(df_filtrado) > 0:
            st.markdown("---")
            st.subheader("üì§ Exportar Resultados Completos")
            
            col_export1, col_export2, col_export3 = st.columns(3)
            
            with col_export1:
                # Exportar para Excel
                output = io.BytesIO()
                with pd.ExcelWriter(output, engine='openpyxl') as writer:
                    df_filtrado.to_excel(writer, index=False, sheet_name='Dados_Filtrados')
                    
                    # Adicionar uma aba com metadados
                    filtros_texto = []
                    for coluna, filtro in filtros_aplicados.items():
                        if isinstance(filtro, list):
                            filtros_texto.append(f"{coluna}: {', '.join(map(str, filtro))}")
                        else:
                            filtros_texto.append(f"{coluna}: {filtro[0]} a {filtro[1]}")
                    
                    metadata = pd.DataFrame({
                        'Par√¢metro': [
                            'Data da consulta', 
                            'Total de registros', 
                            'Registros filtrados',
                            'Filtros aplicados', 
                            'Arquivo original',
                            'Detalhes dos Filtros'
                        ],
                        'Valor': [
                            datetime.now().strftime('%d/%m/%Y %H:%M'),
                            len(df),
                            len(df_filtrado),
                            len(filtros_aplicados),
                            uploaded_file.name,
                            '; '.join(filtros_texto) if filtros_texto else 'Nenhum'
                        ]
                    })
                    metadata.to_excel(writer, index=False, sheet_name='Metadados')
                
                st.download_button(
                    label="üìä Excel Completo",
                    data=output.getvalue(),
                    file_name=f"consulta_comunidades_{datetime.now().strftime('%Y%m%d_%H%M')}.xlsx",
                    mime="application/vnd.ms-excel",
                    use_container_width=True
                )
            
            with col_export2:
                # Exportar para CSV
                csv_data = df_filtrado.to_csv(index=False, encoding='utf-8-sig').encode('utf-8-sig')
                st.download_button(
                    label="üìù CSV Completo",
                    data=csv_data,
                    file_name=f"consulta_comunidades_{datetime.now().strftime('%Y%m%d_%H%M')}.csv",
                    mime="text/csv",
                    use_container_width=True
                )
            
            with col_export3:
                # Exportar apenas colunas selecionadas
                if 'colunas_exibicao' in locals() and colunas_exibicao:
                    csv_selecionado = df_filtrado[colunas_exibicao].to_csv(index=False, encoding='utf-8-sig').encode('utf-8-sig')
                    st.download_button(
                        label="üéØ Colunas Selecionadas",
                        data=csv_selecionado,
                        file_name=f"colunas_selecionadas_{datetime.now().strftime('%Y%m%d_%H%M')}.csv",
                        mime="text/csv",
                        use_container_width=True
                    )

    except Exception as e:
        st.error(f"‚ùå Erro ao processar o arquivo: {str(e)}")
        st.info("üí° Verifique se o arquivo √© um Excel v√°lido e n√£o est√° corrompido.")

else:
    st.info("üëÜ Por favor, envie um arquivo Excel para come√ßar a consulta.")
    
    # Instru√ß√µes de uso
    with st.expander("üìñ Como usar esta ferramenta - NOVAS FUNCIONALIDADES"):
        st.markdown("""
        ## üéØ **Sistema de Busca Inteligente com Sele√ß√£o M√∫ltipla**

        ### üîç **Busca Inteligente:**
        - **Ignora acentos**: "vila" encontra "Vil√£", "Vil√°", "Vila"
        - **Case insensitive**: "norte" encontra "NORTE", "Norte", "nOrTe"
        - **Busca parcial**: "centro" encontra "Centro", "Centro-Sul", "Centro-Oeste"

        ### ‚úÖ **Sele√ß√£o M√∫ltipla em TODOS os Filtros:**
        - **Selecione v√°rias comunidades** de uma vez
        - **Combine varia√ß√µes de escrita**: "Vila Alian√ßa", "vila alianca", "Vila Alianca"
        - **Filtre por m√∫ltiplos problemas** simultaneamente

        ### üí° **Exemplo Pr√°tico:**
        Para encontrar **TODAS** as varia√ß√µes de uma comunidade:
        1. **Busque por "alianca"** (sem acento)
        2. **Selecione TODOS os resultados**: 
           - "Vila Alian√ßa" 
           - "vila alianca"
           - "Vila Alianca"
           - "Comunidade Alian√ßa"

        ### üö® **Problema Resolvido:**
        N√£o importa como foi digitado no cadastro - com acento, sem acento, mai√∫sculas, min√∫sculas - 
        agora voc√™ encontra **TODAS** as varia√ß√µes!
        """)

# Footer
st.markdown("---")
st.caption(f"üïê Sistema de Consulta - Atualizado em {datetime.now().strftime('%d/%m/%Y %H:%M')}")
